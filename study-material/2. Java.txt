-----------------------------------------------------------------------------------------------------------------------------
Index
-----------------------------------------------------------------------------------------------------------------------------
1. OOPs concepts
2. JDK
3. Exception Handling
4. Volatile, AtomicInteger and Types of References
5. String
6. JVM Options
7. Garbage Collection
8. Collections
9. Nested Classes
10. Generics
11. IO (Input / Output)
12. Threads

-----------------------------------------------------------------------------------------------------------------------------
Java
-----------------------------------------------------------------------------------------------------------------------------
http://www.geeksforgeeks.org/java/

Object Oriented Design
-----------------------------------------------------------------------------------------------------------------------------
Language which support below 7 concepts
	1. Encapsulation/Data Hiding
	2. Inheritance
	3. Polymorphism
	4. Abstraction
	5. All predefined types are objects
	6. All user defined types are objects
	7. All operations performed on objects must be only through methods exposed at the objects
Example: Smalltalk

Why Java is not a purely Object-Oriented Language?
	- Java doesn't support property 5 and 7 given above
	- In Java, we have predefined types as non-objects (primitive types)
	- The static keyword: When we declare a class as static then it can be used without the use of an object in Java

Core java
-----------------------------------------------------------------------------------------------------------------------------
# Encapsulation and Abstraction:
------------------------------------------------------
What is difference between Abstraction and Encapsulation in Java?
	Encapsulation is hiding the implementation details which may or may not be for generic or specialized behavior(s).
	Class is the best example of encapsulation.
	Encapsulation means to hide the "How" part of the functionality.
	
	Abstraction is providing a generalization.
	Interface and abstract class are the best examples of abstraction.
	Abstraction means to show "What" part of functionality
	
	1. Abstraction is implemented in Java using interface and abstract class 
	   while Encapsulation is implemented using private, package-private and protected access modifier.
	2. Encapsulation is also called as data hiding.
	3. Design principles 
		- "programming for interface than implementation" is based on abstraction 
	   	- "encapsulate whatever changes" is based upon Encapsulation.

------------------------------------------------------
# Inheritance:
------------------------------------------------------
Why java doesn't allow multiple inheritance?
	- Diamond problem of multiple inheritance
	- Even if it is required it can be substituted with alternate design. 
	- So it is possible to live without multiple inheritance without any issues and that is also one reason.

------------------------------------------------------
# Polymorphism:
------------------------------------------------------
What is Polymorphism?
	Means ability of an object to take many forms.
	Reference variables are good example of polymorphism.

Which object oriented concept is achieved by using overloading and overriding?
	- Polymorphism

What is the difference between static and dynamic polymorphism?
	Static 	- Method overloading (Defining methods with the same name but with different arguments)
		      Which method is to be called is decided at compile-time only.
	Dynamic - Method overriding (Re-defining the methods defined in the super classes)
			  Which method is to be called is decided at run-time only.

------------------------------------------------------
JDK, JRE and JVM
------------------------------------------------------
JDK
	- Provides environment to develop and execute(run) the Java program
	- It includes
		a. Development Tools (to provide an environment to develop your java programs)
		b. JRE (to execute your java program)

JRE 
	- Provides environment to only run (not develop) the java program in your machine
	- It consists
		- JVM
		- Core classes
		- Supporting files

JVM
	- Responsible for executing the java program line by line, hence it is also known as runtime interpreter
	- JVM is an instance of JRE
				 ___________________________			
				|		Sample.java			|			 _______JDK_________
				|			|				|			|					|
	1. Compile	|			|				|			|     Compiler		|
				|			|				|			|___________________|
				|		Sample.class		|					|
				|___________________________|					| Jave byte code
				 ___________|_______________			 _______|___________
				|		Class Loader		|			| 					|
				|			|				|			| 					|
				|		Byte code verifier	| 			|   _____			|
				|			|				|			|  | JIT |  JVM		|
	2. JVM		|		Interpreter			|			|  |_____|			|
				|			|				|			|					|
				|		Runtime				|			|___________________|
				|			|				|			|     Hardware		|
				|		Hardware			|			|___________________|
				|___________________________|			


Does JVM create an object of class Main?
	- No, the reason for main() static in Java is to make sure that the main() can be called without any instance

Is main method compulsory in Java?
	- Prior to JDK 5, main method was not mandatory in a java program
    	You could write your full code under static block and it ran normally
        The static block is first executed as soon as the class is loaded before the main(); method is invoked 
        main() is usually declared as static method and hence Java doesn't need an object to call main method
	- From JDK6 main method is mandatory
		If your program doesn’t contain main method, then you will get a run-time error "main method not found in the class" 

------------------------------------------------------
# Exception handling:
------------------------------------------------------

Checked exceptions?
	- A checked exception is an exception that occurs at the compile time.
	- These are also called as Compile time exceptions. 
	- The programmer should take care of (handle) these exceptions.
	- They cannot be ignored at the time of compilation.

Unchecked exceptions?
	- An unchecked exception is an exception that occurs at the time of execution. 
	- These are also called as Runtime Exceptions. 
	- They are ignored at the time of compilation.
	- These include programming bugs, such as logic errors or improper use of an API. 

Errors?
	- These are not exceptions at all, but problems that arise beyond the control of the user or the programmer. 
	- Errors are typically ignored in your code because you can rarely do anything about an error. 
	- For example, if a stack overflow occurs, an error will arise. 
	- They are also ignored at the time of compilation.

Difference between a runtime (unchecked) exception and a declared (checked) exception?
	-----------------------------------------------------
	|				Throwable (Checked)					|
	|		   _________|___________					|
	|		  |						|					|
	|		Error				Exception (Checked)		|
	|	(Unchecked)					|					|
	|						RuntimeException			|
	|							(Unchecked)				|
	------------------------------------------------------

Eg:
Checked		: FileNotFoundException
Unchecked	: NPE, ArithmeticException, ArrayIndexOutOfBoundsException
							
When would you return an error code instead of throwing an exception?

What is OutOfMemoryError in java? 
	- Is caused due to the memory leak.
	- This error is thrown when there is insufficient space to allocate to an object in the Java heap.

How to deal with java.lang.OutOfMemoryError error?
	- 1. By specifying JVM parameters -Xmx and -XX:MaxPermSize
	- 2. Analyze the heap dump and identify the code which causes high volume of memory.

Sample to generate OutOfMemoryError?
	private static void addingBytes() {
		List<byte[]> list = new ArrayList<>();
		int index = 1;
		while (true) {
			// 1MB each loop, 1 x 1024 x 1024 = 1048576
			byte[] b = new byte[1048576];
			list.add(b);
			Runtime rt = Runtime.getRuntime();
			// Print available free memory
			System.out.printf("[%d] free memory: %s%n", index++, rt.freeMemory());
		}
	}
	
	Output:
	Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
	at com.java.iq.test.JavaOutOfMemory.addingBytes(JavaOutOfMemory.java:18)
	at com.java.iq.test.JavaOutOfMemory.main(JavaOutOfMemory.java:9)
------------------------------------------------------
# General concepts:
------------------------------------------------------
What are the different ways to create objects in Java?
	1. Using 'new' keyword: This is the most common way to create an object in Java.
		MyObject object = new MyObject();
		
	2. Using newInstance()
		-  If we know the name of the class and if it has a public default constructor we can create an object as below
			String st = (String) Class.forName("java.lang.String").newInstance();

	3. Using cloning Concept
    	- Class need to implement Cloneable Interface otherwise it will throw CloneNotSupportedException.
    	- Here we are creating the clone of an existing Object and not any new Object
			MyObjectName anotherObject = new MyObjectName();
			MyObjectName object = anotherObjectName.clone(); //cloning Object

	4. Using deserialization
		- When we serialize and then deserialize an object, JVM creates a separate object
		- In deserialization, JVM doesn’t use any constructor to create the object
		- To deserialize an object we need to implement the Serializable interface in the class
			a. Serialize:
				Sample sample = new Sample("GeeksForGeeks");
            	FileOutputStream f = new FileOutputStream("file.txt");
            	ObjectOutputStream oos = new ObjectOutputStream(f);
            	oos.writeObject(sample);

			b. Deserialize
				FileInputStream f = new FileInputStream("file.txt");
           	 	ObjectInputStream ois = new ObjectInputStream(f);
           		Sample sample = (Sample)ois.readObject();
	
	5. Using Factory Method
		RunTime rt = Runtime.getRunTime(); //Static Factory Method
    
What is the difference between abstract class, concrete class, instance and interface?
	- Abstract classes can have constants, members, method stubs (methods without a body) and defined methods
      Interfaces can only have constants and methods stubs
    - Methods and members of an abstract class can be defined with any visibility
      All methods of an interface must be defined as public
    - A child class can define abstract methods with the same or less restrictive visibility
      A class implementing an interface must define the methods with the exact same visibility (public)
      
What is the significance of volatile keyword in Java?
	- It can only be used with a variable
	- It also guarantees visibility and ordering (It will always be read from main memory and not from Thread's local cache.)
	- If variable is not shared between multiple threads, you don't need to use volatile keyword with that variable.
	
	- Visibility Guarantee
		- In a multithreaded application where the threads operate on non-volatile variables, each thread may copy variables from 
		  main memory into a CPU cache while working on them, for performance reasons. 
		  If your computer contains more than one CPU, each thread may run on a different CPU.
		- With non-volatile variables there are no guarantees about when the Java Virtual Machine (JVM) reads data from 
		  main memory into CPU caches, or writes data from CPU caches to main memory.
			public class SharedObject {
				public int counter = 0;
			}
		- If the counter variable is not declared volatile there is no guarantee about when the value of the counter variable 
		  is written from the CPU cache back to main memory. 
		  This means, that the counter variable value in the CPU cache may not be the same as in main memory
		- The problem with threads not seeing the latest value of a variable because it has not yet been written back to 
		  main memory by another thread, is called a "visibility" problem.
			public class SharedObject {
				public volatile int counter = 0;
			}
		- Declaring a variable volatile thus guarantees the visibility for other threads of writes to that variable. 
					
	- Happens-before Guarantee
		- The happens-before guarantee guarantees that read and write instructions of volatile variables cannot be reordered. 
		- Instructions before and after can be reordered, but the volatile read/write instruction cannot be reordered with 
		  any instruction occurring before or after it.
		- Look at this example:
			-------------------------------------------------------------
			|sharedObject.nonVolatile1 = 123;							|
			|sharedObject.nonVolatile2 = 456;							|
			|sharedObject.nonVolatile3 = 789;							|
			|															|
			|sharedObject.volatile     = true; //a volatile variable	|
			|															|			
			|int someValue1 = sharedObject.nonVolatile4;				|
			|int someValue2 = sharedObject.nonVolatile5;				|
			|int someValue3 = sharedObject.nonVolatile6;				|
			-------------------------------------------------------------
			- The JVM may reorder the first 3 instructions, as long as all of them happens before the volatile write instruction 
			  (they must all be executed before the volatile write instruction).
			- Similarly, the JVM may reorder the last 3 instructions as long as the volatile write instruction happens before 
			  all of them. None of the last 3 instructions can be reordered to before the volatile write instruction.
			- That is basically the meaning of the Java volatile 'happens-before guarantee'.
	
	- Usage:
		1. Can be used if you want to read and write 'long' and 'double' variable 'atomically'.
		2. Can be used as an alternative way of achieving 'synchronization' in Java in some cases, like Visibility.
		3. Can be used to inform the compiler that a particular field is subject to be accessed by multiple threads, which will prevent 
		   the compiler from doing any reordering or any kind of optimization on the code.
		4. Can be used to fix "double checked locking" in Singleton pattern.
/**
 * Java program to demonstrate where to use Volatile keyword in Java.
 * In this example Singleton Instance is declared as volatile variable to ensure every thread see updated value for _instance.
 */
public class Singleton{
	private static volatile Singleton _instance; // volatile variable 

	public static Singleton getInstance(){
		if(_instance == null){
            synchronized(Singleton.class){
              if(_instance == null)
              _instance = new Singleton();
            }

   		}
   	return _instance;
	}
}

When is volatile enough?
	- If two threads are both reading and writing to a shared variable, then using the volatile keyword for that is not enough. 
	- You need to use a synchronized in that case, to guarantee that the reading and writing of the variable is atomic.
	- As an alternative to a synchronized block you could also use one of the many atomic data types 
	  found in the java.util.concurrent package. 
	  For instance, the AtomicLong or AtomicReference or one of the others. 
	
What is difference between synchronized and volatile?
	1. The volatile keyword in Java is a field modifier 
       while synchronized modifies code blocks and methods
    2. Synchronized obtains and releases the lock on monitor’s 
       Volatile keyword doesn't require that
    3. Threads can be blocked for waiting for any monitor in case of synchronized
       that is not the case with the volatile keyword
    4. Synchronized method affects performance more than a volatile keyword in Java.
    5. Since volatile keyword only synchronizes the value of one variable between Thread memory and "main" memory
       while synchronized synchronizes the value of all variable between Thread memory and "main" memory 
       and locks and releases a monitor to boot 
       Due to this reason synchronized keyword is likely to have more overhead than volatile
    6. You can not synchronize on the 'null' object 
       but volatile variable could be 'null'
    7. From Java 5 writing into a volatile field has the same memory effect as a monitor release
       and reading from a volatile field has the same memory effect as a monitor acquire

What is Volatile Integer and AtomicInteger?
	- AtomicInteger, AtomicReference are based on the 'Compare and swap instruction'. 
	- CAS has three operands: a memory location V on which to operate, the expected old value A, and the new value B. 
	- CAS atomically updates V to the new value B, but only if the value in V matches the expected old value A; otherwise it does nothing. 
	- In either case, it returns the value currently in V. 
	- This is used by JVM in AtomicInteger, AtomicReference and they call the function as compareAndSet(). 
	- If this functionality is not supported by underlying processor then JVM implements it by spin lock.
	
If we don't have volatile, AtomicInteger or Synchronized how do we achieve thread safe for incrementing variable.
	- Volatile 
		- means modifying its value immediately affects the actual memory storage for the variable. 
		- The compiler cannot optimize away any references made to the variable. 
		- This guarantees that when one thread modifies the variable, all other threads see the new value immediately. 
	- Atomic
		- guarantees that operations made on the variable occur in an atomic fashion, 
		  i.e., that all of the substeps of the operation are completed within the thread they are executed 
		  and are not interrupted by other threads. 
		- For example, an increment-and-test operation requires the variable to be incremented 
		  and then compared to another value; an atomic operation guarantees that both of these steps will be completed 
		  as if they were a single indivisible/uninterruptible operation.
	- Synchronized
		- allows only a single thread at a time to access the variable, 
		  and forces all other threads to wait for that accessing thread to release its access to the variable. 
		- Is similar to atomic access but the atomic operations are generally implemented at a lower level of programming.

Note: Atomicity, synchronization, and volatility are independent attributes, 
      but are typically used in combination to enforce proper thread cooperation for accessing variables.

Hypothetic question: If by mistake instead of updating the next address location in LinkedList, is updated the previous address. 
	- How do we find and resolve it.

Have you heard of weak/strong references in java? Can you explain?
	1. Strong Reference
		Object in the memory which has active strong reference 
		Is not eligible for garbage collection. 
		For example, in the below program, reference variable ‘a’ is a strong reference which is pointing to class A-type object. 
			A a = new A(); //Strong Reference
 			a = null;
		At this point of time, this object can’t be garbage collected as it has strong reference.
		If you make reference 'a' to point to null, 
		then object to which 'a' was pointing earlier will become eligible for garbage collection.
		
	2. Soft Reference
		Objects which are softly referenced will not be garbage collected until JVM badly needs memory. 
		These objects will be cleared from the memory only if JVM runs out of memory.
			A a = new A();      //Strong Reference
			//Creating Soft Reference to A-type object to which 'a' is also pointing
 		    SoftReference<A> softA = new SoftReference<A>(a);
			a = null;   // Now, A-type object to which 'a' is pointing earlier is eligible for garbage collection.
						// But, it will be garbage collected only when JVM needs memory.
			a = softA.get();
	
	3. Weak Reference
		Objects which have only week references are eligible for garbage collection. 
		They are likely to be garbage collected when JVM runs garbage collector thread. 
		JVM doesn’t show any regard for weak references.
		Calling get() method, JVM will return reference to the object if object is not yet removed from the memory.
			A a = new A();      // Strong Reference
 			// Creating Weak Reference to A-type object to which 'a' is also pointing.
 			WeakReference<A> weakA = new WeakReference<A>(a);
 			a = null;    // Now, A-type object to which 'a' is pointing earlier is available for garbage collection.
 			a = weakA.get(); 
	
	4. Phantom Reference
		The objects which are being referenced by phantom references are eligible for garbage collection. 
		But, before removing them from the memory, JVM puts them in a queue called ‘reference queue’. 
		They are put in a reference queue after calling finalize() method on them. 
		You can’t retrieve back the objects which are being phantom referenced. 
		That means calling get() method on phantom reference always returns null.
			A a = new A();      //Strong Reference
        	// Creating ReferenceQueue
        	ReferenceQueue<A> refQueue = new ReferenceQueue<A>();
        	// Creating Phantom Reference to A-type object to which 'a' is pointing
        	PhantomReference<A> phantomA = new PhantomReference<A>(a, refQueue);
        	a = null;   // Now, A-type object to which 'a' is pointing earlier is available for garbage collection. 
        				// But, this object is kept in 'refQueue' before removing it from the memory.
        	a = phantomA.get();    // It always returns null

------------------------------------------------------
# String:
------------------------------------------------------
What is the difference between the String and StringBuffer classes?
	- String 
		- Is immutable (once created can not be changed) object
		- Is thread safe (Every immutable object in Java is thread safe)
	  	- Object is stored in the Constant String Pool
	  	
	- StringBuffer 
		- Is mutable
		- Is thread safe
		- Object is stored in the heap
		
	- StringBuilder
		- Is mutable
		- Is not thread safe
		- Object is stored in the heap
		- StringBuilder is fast compared to StringBuffer

What is the difference between String class and string literal?
	String class 
		- Always creates a new object in heap.	
		- Put any object to String pool by calling intern() method of java.lang.String class.
		
	String literal 
		- Creates an object in String pool (Perm area of heap) if absent, otherwise it will return the existing object reference.
		- By default Java will call intern() method.

	String pool:
		Up-to Java 1.6 String pool is located in permgen area of heap, but in Java 1.7 its moved to main heap area.
		Default size is 64 MB.
		Creating too many String literals can cause java.lang.OutOfMemory: permgen space.

How to make a class immutable?
    1. Declare the class as final - Don't allow subclasses to override methods
    2. Make all fields final and private.
    3. Don't provide "setter" methods — methods that modify fields or objects referred to by fields.
    4. A more sophisticated approach is to make the constructor private and construct instances in factory methods.
	
	// Class is final so we cannot create the subclass
	public final class MyString {
		// Is immutable as it does not provide setter to change its content
		// Is final, so we cannot change the value of it after creating an object
		private final String field;
		
		public MyString (String field){
			this.field = field;
		}
		
		public String getField(){
			return this.field;
		}   
	}
	
	// Class is final so we cannot create the subclass.
	public final class MyString {
		// Is immutable as it does not provide setter to change its content
    	private final String field;
		
		// Default private constructor will ensure no unplanned construction of class
		private MyString (String field) { 
			this.field = field;
		}
		
		// Factory method to store object creation logic in single place
		public static MyString createInstance(String field){
			return new MyString(field);
		}
		
		public String getField(){
			return this.field;
		}   
	}

-----------------------------------------------------------------------------------------------------------------------------
JVM Options
-----------------------------------------------------------------------------------------------------------------------------
http://www.oracle.com/technetwork/articles/java/vmoptions-jsp-140102.html
https://www.ibm.com/support/knowledgecenter/SSYKE2_7.0.0/com.ibm.java.lnx.70.doc/diag/appendixes/cmdline/cmdline.html

1. General command line options (eg: -cp, -help, -version)

2. System property command line options (eg: -D<name>=<value>)
    - Sets a system property

3. JVM -X command line options (eg: -Xmx500m)
    - Options prefixed with -X are nonstandard

4. JVM -XX: command line options (-XX:MaxPermSize=1g)
    - Options that are specified with -XX: are not checked for validity. 
      If the VM does not recognize the option, the option is ignored

-----------------------------------------------------------------------------------------------------------------------------
# Garbage-Collection
-----------------------------------------------------------------------------------------------------------------------------
Garbage collection thread is a daemon thread which will run by JVM based upon GC algorithm.
When runs it collects all objects which are eligible for GC.

What is structure of Java Heap? What is Perm Gen space in Heap ?
	- Heap is divided into different generation e.g. new generation, old generation and PermGen space
	- PermGen space is used to store class metadata and string pool data
	- Filling of PermGen space can cause java.lang.OutOfMemory:PermGen space
	  By setting correct size to -Xmx and -XX:MaxPermSize we may avoid OutOfMemory errors

	|___________________________-Xmx ____________________________|______-XX:MaxPermSize______|
	|												 			 |							 |
	|		 |____________________-Xms _________________|		 |___-XX:PermSize___|		 |
	|		 |										 	|		 |					|		 |
	|		 |_-XX:NewSize__|						 	| 		 |					|		 |
	|		 |			  	|						 	| 		 |					|		 |
	------------------------------------------------------------------------------------------
	|		 |		|	 	|	  	|					|		 |					|		 |
	|reserved|  to	| from	| eden 	|		tenured		|reserved|	     perm		|reserved|
	|	     |		|	 	|	  	|					|		 |					|		 | 
	------------------------------------------------------------------------------------------
	|		 						|				 	|		 |					|		 |
	|________-XX:MaxNewSize_________|					|		 |					|		 |

	|<----Young Generation--------->|<------Old Generation------>|<----Perm generation------>|

How do you monitor garbage collection activities?
    - We can monitor garbage collection activities either offline or real-time
    
    - Real time analysis
        - Use tools like JConsole and VisualVM to monitor real time garbage collection activities and memory status of JVM 
        - We can enable GC options like (it doesn't impact application performance)
            -XX:+PrintGCDetails 
            -verbose:gc
            -XX:+PrintGCTimeStamps 

    - Offline analysis
        - Redirect Garbage collection output to a log file for offline analysis by using JVM parameter
          -XlogGC=<PATH>
        
    - Generate a heap dump on OutOfMemoryError
        -XX:+HeapDumpOnOutOfMemoryError
        -XX:HeapDumpPath=/Users/manju_kogunde

How do you identify minor and major garbage collection in Java?
	- Minor collection prints “GC” if garbage collection logging is enabled using –verbose:gc or -XX:PrintGCDetails, 
	- Major collection prints “Full GC”. 

How do you find GC resulted due to calling System.gc()?
	- There will be a word “System” included in Garbage collection output
	
Does Garbage collection occur in permanent generation space in JVM?
	- Garbage Collection does occur in PermGen space
	- If PermGen space is full or cross a threshold, it can trigger Full GC.

What is difference between ParNew and DefNew Young Generation Garbage collector?
	- ParNew and DefNew are two young generation garbage collector
	- ParNew is a multi-threaded GC used along with concurrent Mark Sweep
	- DefNew is a single threaded GC used along with Serial Garbage Collector

What is difference between Serial and Throughput Garbage collector?
	- Serial GC is most suited for small application
	  Throughput GC is more suited for large applications
	- Serial GC stops application thread from running during both minor and major collection
	  Throughput garbage collector is parallel collector where minor and major collection happens in parallel
	- Serial GC can be enabled using -XX:UseSerialGC
	  Throughput Garbage collector can be enabled using -XX:UseParallelGC or -XX:UseOldParallelGC

When does an Object become eligible for Garbage collection in Java ?
	- An object becomes eligible for garbage collection when there is no live reference for that object 
	  or it can not be reached by any live thread. 
	- Cyclic reference doesn’t count as live reference and if two objects are pointing to each other 
	  and there is no live reference for any of them, than both are eligible for GC. 

If Object A has reference to Object B and Object B refer to Object A, apart from that there is no live reference to either object A or B.
Are they are eligible for Garbage collection?
	- An object becomes eligible for Garbage collection if there is no live reference for it. 
	- It can not be accessible from any Thread and cyclic dependency doesn’t prevent Object from being Garbage collected. 
	- Which means in this case both Object A and Object B are eligible for Garbage collection.

What is finalize method in Java? When does Garbage collector calls finalize method in Java?
	- Finalize method is also called finalizer
	- Is a method defined in java.lang.Object 
	- Invoked by Garbage collector before collecting any object which is eligible for GC
	- Finalize() method provides last chance for object to do cleanup and free any remaining resource

Can we force Garbage collector to run at any time ?
	- No, you can not force Garbage collection in Java. 
	- Though you can request it by calling Sytem.gc() or its cousin Runtime.getRuntime().gc(). 
	- It’s not guaranteed that GC will run immediately as a result of calling these method.

In Java, how and when are objects garbage-collected? What sorts of problems can you run into using garbage-collection?

-----------------------------------------------------------------------------------------------------------------------------
# Collections:
-----------------------------------------------------------------------------------------------------------------------------
Collection : A collection (also called as container) is an object that groups multiple elements into a single unit.
Collections Framework : Collections framework provides unified architecture for manipulating and representing collections.

What is the root interface in collection hierarchy? 
	- Root interface in collection hierarchy is Collection interface
	- Collection interface extends Iterable interface.
	- Collection interface is a member of the Java Collections framework 
	  but iterable interface is not mentioned as a part of the Java Collections framework.

What is the difference between Collection and Collections ?
	- Collection is an interface while Collections is a java class.
	- Both are present in java.util package and part of java collections framework.
	
***************************************************************************************************************************************
                                                         Iterable(I)
                                                             |
                                                         Collection(I)
                _____________________________________________|_____________________________________________
               |                                             |                                             |
             Set(I)                                       List(I)                                       Queue(I)
    ___________|___________                                  |                                 ____________|____________
   |                       |                            AbstractList                          |                         |
AbstractSet            SortedSet(I)               ___________|___________        		    Deque(I)               	AbstractQueue    
   |                       |                     |           |           |              	  |                         |
HashSet                NavigableSet(I)      ArrayList     Vector(S)  LinkedList 	AbstractSequentialList     		PriorityQueue
   |                       |                                 |                
LinkedHashSet          TreeSet                             Stack(S)

______________________________________________________________________________________________________________________________________


Dictionary                                                     	 Map(I)
  |     ___________________________________________________________|___________________________________________________________
  |    |                                      |                                                  	 |                         |
Hashtable(S)                             AbstractMap                                        ConcurrentMap(I)          		SortedMap(I)                                
    |                _________________________|______________________________                        |                         |
Properties(S)       |             |           |                 |            |             	ConcurrentNavigableMap(I)     	NavigableMap(I)
                  HashMap    WeakHashMap    EnumMap   IdentityHashMap   ConcurrentHashMap                                      |                               
                    |                                                                                                       TreeMap   
               LinkedHashMap                                                                     
   

***************************************************************************************************************************************

Which collection classes are synchronized or thread-safe ?
	- Vector, Stack, Hashtable and Properties

What is the difference between List and Set?
	- Set contain only unique elements
	  List can contain duplicfate elements
	- Set is unordered
	  List is ordered (List maintains the order in which the objects are added)
	- Set allows only one null element
	  List allows many null elements

What is the difference between Map and Set?
	- Map contains 'unique keys' but can hold duplicate values
	  Set contains only 'unique values'
	
What is an iterator?
	- Iterator is an interface
	- It is found in java.util package
	- It provides methods to iterate over any Collection

What is the difference between Iterator and Enumeration?
	- Iterator has remove() method
	  Enumeration doesn't
	- Iterator can manipulate objects by adding and removing the objects from the collections
	  Enumeration acts as Read-only interface
	- Iterator is more secure and safe as compared to Enumeration 
	  because it does not allow other thread to modify the collection object while some thread is iterating over it
	  and throws ConcurrentModificationException
	- In Summary both Enumeration and Iterator will give successive elements
	  But Iterator is new and improved version where method names are shorter and has new method called remove
	- Enumeration:
		hasMoreElement()
		nextElement()
	-  Iterator
		hasNext()
		next()
		remove()

Which methods you need to override to use any object as key in HashMap?
	- We need to override equals() and hashCode() method

What is the difference between Queue and Stack?
	- Queue is a data structure which is based on FIFO (first in first out) property.
	  Stack is a data structure which is based on LIFO (last in first out) property

How to reverse the List in Collections?
	- Collections.reverse(List list)

How to convert the array of strings into the list?
	- String[]  wordArray =  {"Love Yourself"  , "Alive is Awesome" , "Be in present"};
	- List wordList =  Arrays.asList(wordArray);

What is the difference between ArrayList and Vector?
	- Vector is synchronized 
	  ArrayList is not
	- Vector increases the capacity twice of its initial size 
	  ArrayList increases its ArraySize by 50%
	- Vector allows to set the increment size (setSize(int i))
	  ArrayList does not
	- Other than Hashtable, Vector is the only other class which uses both Enumeration and Iterator
	  ArrayList can only use Iterator for traversing an ArrayList

Note: 
	- By default ArrayList size is 10 
	- In ArrayList, remove(int) method involves copying elements from old array to new updated array, hence its run time is O(n).
	
How ArrayList resize happens?
	- int newCapacity = ((oldCapacity * 3)/2) + 1;

What is the difference between LinkedList and ArrayList in Java ?
	- LinkedList is the Doubly-linked list implementation of the list interface
	  ArrayList is the resizable (dynamic) array implementation of list interface
	- ArrayList initial capacity is 10
	  LinkedList only constructs the empty list without any initial capacity
	- LinkedList can be iterated in reverse direction using descendingIterator()
	  ArrayList doesn't have descendingIterator()
	- Memory overhead in LinkedList is more as compared to ArrayList 
	  as node in LinkedList needs to maintain the addresses of next and previous node
	  While in ArrayList each index only holds the actual object (data)

What is the difference between Iterator and ListIterator?
	- ListIterator can traverse the collection in both directions
	  Iterator traverses the list of objects in forward direction only
	- ListIterator can be used to traverse only List-type Objects
	  Iterator can be used to traverse List, Set and Map type of Objects
	- With List Iterator you can obtain the index at any point while traversing
	  With Iterator it is not possible
	- With ListIterator we can add new element at any point of time
	  With Iterator we cannot add new elements
	- With list iterator you can modify an element while traversing
	  With Iterator it is not possible

	- Iterator:
		public interface Iterator<E> {
			boolean hasNext();
			E next();
			void remove(); //optional-->use only once with next(), dont use it when u use for:each
		}
		
    - ListIterator:
   		public interface ListIterator<E> extends Iterator<E> {
			boolean hasNext();
			E next();
			boolean hasPrevious();
			E previous();
			int nextIndex();
			int previousIndex();
			void remove(); //optional
			void set(E e); //optional
			void add(E e); //optional
		}

Why Map interface does not extend the Collection interface in Java Collections Framework ?
	- Map interface is not compatible with the Collection interface
	
What is the difference between HashMap and Hashtable ?
	- HashMap is not synchronized
	  Hashtable is synchronized
	- HashMap allows one null key and any number of null values
	  Hashtable does not allow null keys and null values
	- HashMap object values are iterated by using iterator
	  Hashtable object values are iterated by using Enumerator and Iterator
	- HashMap iterator is fail-fast
	  Hashtable iterator is fail-safe
	- HashMap is much faster and uses less memory than Hashtable, as former is unsynchronized
	
Fail-Fast vs Fail-Safe?
	- Fail-Fast iterators throw an exception(ConcurrentModificationException) if the collection is modified while iterating over it.
	- Examples : ArrayList, HashMap
	- Fail-Fast Iterators internal working
		Every fail fast collection has a modCount field, to represent how many times the collection has changed/modified.
		So at every modification of this collection we increment the modCount value. 
		For example the modCount is incremented in below cases:
		1. When one or more elements are removed.
		2. When one or more elements are added.
		3. When the collection is replaced with other collection.
		4. When the collection is sorted.
		So everytime there is some change in the collection structure, the mod count is incremented.

	- Fail-Safe iterators will not throw any exception even if the collection is modified while iterating over it. 	
	- Examples: CopyOnWriteArrayList, ConcurrentHashMap
	- Fail-Safe Iterators internal working:
		These iterators traverse over the clone of the collection. 
		So even if the original collection gets structurally modified, no exception will be thrown.
		E.g. in case of CopyOnWriteArrayList the original collections is passed and is stored in the iterator
	- Note: although it does not throw any exception, but the downsides of this iterator are
		1. They will not reflect the latest state of the collection.
		2. It requires extra memory as it clones the collection.
	- Example of Fail-Safe Iterator which does not create separate copy
		
		// Java program to illustrate Fail-Safe Iterator which does not create separate copy 
		import java.util.concurrent.ConcurrentHashMap; 
		import java.util.Iterator; 
		  
		public class FailSafeItr { 
		    public static void main(String[] args) { 
		        // Creating a ConcurrentHashMap 
		        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<String, Integer>(); 
		  
		        map.put("ONE", 1); 
		        map.put("TWO", 2); 
		        map.put("THREE", 3); 
		        map.put("FOUR", 4); 
		  
		        // Getting an Iterator from map 
		        Iterator it = map.keySet().iterator(); 
		  
		        while (it.hasNext()) { 
		            String key = (String)it.next(); 
		            System.out.println(key + " : " + map.get(key)); 
		  
		            // This will reflect in iterator. Hence, it has not created separate copy 
		            map.put("SEVEN", 7); 
		        } 
		    } 
		} 
		
		Output
		
		ONE : 1
		FOUR : 4
		TWO : 2
		THREE : 3
		SEVEN : 7

		Note: The iterators returned by ConcurrentHashMap is weakly consistent. 
			  This means that this iterator can tolerate concurrent modification, 
			  traverses elements as they existed when iterator was constructed and 
			  may (but not guaranteed to) reflect modifications to the collection after the construction of the iterator.
	
What is the difference between HashMap and ConcurrentHashMap ?
	- HashMap is not synchronized
	  ConcurrentHashMap is synchronized
	- HashMap can have one null key and any number of null values
	  ConcurrentHashMap does not allow null keys and null values
	- HashMap is usually faster than ConcurrentHashMap

How HashMap works internally? 
	- HashMap works on the principle of Hashing
	- To understand Hashing, we should understand the three terms first i.e  Hash Function, Hash Value and Bucket (using hashCode() modulo number_of_buckets)
		- hashCode() is the "Hash Function" which returns int value
		- This int value is called "Hash Value"
		- A bucket is used to store key value pairs
	- A bucket can have multiple key-value pairs
	- Bucket uses simple linked list to store objects
	
	get(Key k) and put(Key k, Value v):
	- HashMap get(Key k) method calls hashCode method on the key object 
      and applies returned hashValue to its own static hash function to find a bucket location (backing array) 
      where keys and values are stored in the form of a nested class called Entry (Map.Entry)
    - If key is null, then Null keys always map to hash 0, thus index 0
    - If key is not null then, it will call hashfunction on the key object 
      and now it applies returned hashValue into its own hashing function, to find final hash value
    - Final hashvalue is used to find the bucket location at which the Entry object is stored
    - Entry object stores in the bucket like this (hash,key,value,nextEntryReference) 
    - If two Keys are having same hashCode, here equals() method comes to the rescue
      The bucket is a linked list effectively. Its not a LinkedList as in a java.util.LinkedList.
      It's a separate (simpler) implementation just for the map.
      So we traverse through linked list, comparing keys in each entries using keys.equals() until it returns true.
      Then the corresponding entry object value is returned (or inserted in case of put()).

Performance Improvement of HashMap in Java8?
	Java 8 is on average 20% faster than Java 7 in simple HashMap.get()
	
	What is the reason behind such a tremendous performance improvement, even in terms of big-O notation? 
		Well, this optimization is described in JEP-180. 
		Basically when a bucket becomes too big (currently: TREEIFY_THRESHOLD = 8), 
		HashMap dynamically replaces it with an ad-hoc implementation of tree map. 
		This way rather than having pessimistic O(n) we get much better O(log n). 
	
	How does it work? 
		Well, previously entries with conflicting keys were simply appended to linked list, which later had to be traversed. 
		Now HashMap promotes list into "binary tree"", using hash code as a branching variable. 
		If two hashes are different but ended up in the same bucket, one is considered bigger and goes to the right. 
		If hashes are equal (as in our case), HashMap hopes that the keys are "Comparable", so that it can establish some order. 
		This is not a requirement of HashMap keys, but apparently a good practice. 
		Note: If keys are not comparable, don't expect any performance improvements in case of heavy hash collisions.

	Why is all of this so important? 
		Malicious software, aware of hashing algorithm we use, might craft couple of thousand requests that will result in massive hash collisions. 
		Repeatedly accessing such keys will significantly impact server performance, effectively resulting in denial-of-service attack. 
		In JDK 8 an amazing jump from O(n) to O(logn) will prevent such attack vector, also making performance a little bit more predictive. 
		I hope this will finally convince your boss to upgrade.

What is hash-collision? How does java handle Hash collision?
	- If two different keys have the same hash value then it leads to hash-collision
	- A bucket (of type linkedlist) is used to hold the different keys of same hash value
	
What is initial capacity (16) and load factor (0.75) of a HashMap?
	- The capacity is the number of buckets in the hash table 
	  (HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls)
	- The initial capacity is simply the capacity at the time the hash table is created
	- The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased

How HashMap resize happens?
    - Before adding the new Entry, put(…) checks if size > threshold and if it is the case it recreates a new array with a doubled size. 
    - Since the size of the new array has changed, the indexing function (which returns the bitwise operation “hash(key) AND (sizeOfArray-1)”) changes.
    - So, the resizing of the array creates twice more buckets (i.e. linked lists) and redistributes all the existing entries into the buckets.

What is the time complexity of Hashmap get() and put() method ?
	- The hashmap implementation provides constant time performance for (get and put) basic operations
	- The complexity of get() and put() is O(1), assuming the hash function disperses the elements properly among the buckets
	
What happens when a hash map exceeds a given threshold defined by load factor? Do you see any problems there?
	- When the number of entries in the hash table exceeds the 'product of the load factor and the current capacity', 
	  the hash table is rehashed (that is, internal data structures are rebuilt)
	  so that the hash table has approximately twice the number of buckets
	- Re-hashing and extension of memory will take place, which in-turn affects the performance
	
Why String, Integer and other Wrapper objects are considered to be good Keys for HashMap?
	- Any class can serve as a key if and only if it overrides the equals() and hashCode() method
	- By default, Wrapper classes override equals() and hashCode() methods. Hence they are good keys for HashMap

How HashSet works internally?
	- When we create an object of HashSet it will internally create an object of HashMap
	- HashMap is used to achieve uniqueness
	- In HashMap each key is unique
	- We pass the argument in the add(Elemene E), that is E as a key in the HashMap
	- A dummy value is assigned to the key, that is (new Object ())
	- Example - when you are adding a line in HashSet like hashset.add(3),
	  java internally will put that element E, here 3, as a key in the HashMap (created during HashSet object creation)
	  and some dummy value that is Object's object is passed as a value to the key
	- The main point to notice is that put (key,value) will return
		1.  null, if key is unique and added to the map
		2.  Old value of the key, if key is duplicate
	- In HashSet add() method, we check the return value of map.put(key,value) method with null value
		public boolean add(E e) {
			return map.put(e, PRESENT)==null;
       	}
    - If map.put(key,value) returns null, 
      then HashSet's add() method will return true and element is added to the HashSet

	- If map.put(key,value) returns old value of the key, 
	  then HashSet's add() method will return false and element is not added to the HashSet

What is Default Initial Capacity (16) and Initial Load Factor (0.75) of HashSet?

Why HashSet does not have get(Object o) method?
	- get(Object o) is useful when we have one information linked to other information just like key value pair found in HashMap
	- So using get() method on one information we can get the second information or vice-versa
	- Unlike HashMap, HashSet is all about having unique values or unique objects
	- There is no concept of keys in HashSet
	- The only information we can derive from the HashSet object is whether the element is present in the HashSet Object or not
	- If the element is not present in the HashSet then add it otherwise return true leaving HashSet object unchanged
	- Here, contains() method helps to provide this information

Difference between HashSet and TreeSet?
	- HashSet is internally backed by HashMap
	  TreeSet is backed by a NavigableTreeMap
	- HashSet can store null object
	  TreeSet does not allow null object
	  If one try to store null object in TreeSet object, it will throw Null Pointer Exception
	- HashSet stores the object in random order
	  TreeSet stores the objects in the sorted order (according to the natural ordering of its elements)
	- HashSet is much faster than TreeSet

deep copy and shallow copy?
	- Shallow copy is made by copying the reference of the object
	- HashSet internally uses shallow copy in clone() method, the elements themselves are not cloned.

What is the difference between Synchronized Map and Concurrent Map?
How a ConcurrentHashMap works?
What is a difference between a tree and a graph?
What is the order of look-up and insertion in a hash table, binary tree, linked list?
Name as many sorting algorithms as you can and briefly characterize their performance characteristics.
Why would you use a link list rather than an array? Discuss the tradeoffs.

What are Comparable and Comparator interfaces ? List the difference between them ?
	- Comparable interface is used to implement natural ordering of objects
	  Comparator interface is used to implement customised ordering of objects
	- Comparable interface has method 'public int compareTo(Object o)'
	  Comparator interface has method 'public int compare (Object o1, Object o2)'

Have you involved in design activities? What is the difference between association, aggregation and composition?
    - http://javarevisited.blogspot.com/2014/02/ifference-between-association-vs-composition-vs-aggregation.html#ixzz4sItVca2Z
    
    - All three denotes relationship between objects and only differ in their strength.
      Composition represents strongest form of relationship and association being the most general form
    - Another interesting word, to understand difference between Composition and Aggregation in software design is "part-of" and "has"
      If one object is-part-of another object e.g. Engine is part of Car, then association or relationship between them is Composition
      If one object just has another object e.g. Car has the driver then it's Aggregation

    - Association: One object is related to other to use functionality and service provided by that object
                     This relationship between two objects is known as the Association
                     Both Composition and Aggregation are the forms of association between two objects

    - Composition: Association between two objects is referred as Composition, 
                   when one class owns other class and other class can not meaningfully exist, when it's owner is destroyed
                   Composition is also called as "Strong Aggregation"
                   For example: Car and it's parts like engines, wheels etc, individual parts of the car can not function when a car is destroyed
                   Here is how they are implemented between Java classes
                   
                   public class Car {
                        //final will make sure engine is initialized
                        private final Engine engine;  
                           
                        public Car(){
                           engine  = new Engine();
                        }
                    }
                    
                    class Engine {
                        private String type;
                    }
    
    - Aggregation: Association between two objects is referred as Aggregation, 
                   when one class can exists without being part of the other class
                   For example: Organization has Person as employees, the relationship between them is Aggregation.
                   Here is how they look like in terms of Java classes
                   
                    public class Organization {
                        private List<Person> employees;
                    }
                    
                    public class Person {
                        private String name;   
                    }
                   
    - UML notation: In UML notation, a composition is denoted by a filled diamond
                    While aggregation is denoted by an empty diamond
                    which shows their obvious difference in terms of strength of the relationship
                    Association  A----->B
                    Composition  A-----<filled>B
                    Aggregation  A-----<>B
                    Inheritance  A-----|>B

How do you implement an aggregation and composition in Java?
    - Aggregation can be achieved by holding a property of one entity in another
    - Composition can be achieved by using an inner class or by declaring property as 'final'

Difference between Integer.valueOf() vs. Integer.parseInt()
	- Integer.valueOf() returns a new Integer object
	- Integer.parseInt() returns a primitive int

-----------------------------------------------------------------------------------------------------------------------------
Nested Classes in Java
-----------------------------------------------------------------------------------------------------------------------------
http://www.geeksforgeeks.org/nested-classes-java/

Classes defined within another class are known as nested classes
	- The scope of a nested class is bounded by the scope of its enclosing class. 
	- A nested class has access to the members, including private members, of the class in which it is nested
	  However, reverse is not true
	- A nested class is also a member of its enclosing class
	- A nested class can be declared private, public, protected, or package private(default)
	- Nested classes are divided into two categories:
    	a. static nested class : Nested classes that are declared static are called static nested classes
    	b. inner class : A non-static nested class are called inner class
    					
    					Nested Class
				______________|______________
    	       |						 	 |
    	Static Nested Class				Inner Class
    								 ________|________
    								|                 |
    						  Local Class		Anonymous Class


----------------------------------------
Static Nested Class
----------------------------------------
	- Static nested class cannot refer directly to instance variables or methods defined in its enclosing class
	- It can use them only through an object reference
	- Static nested classes are accessed using the enclosing class name
	- To create an object for the static nested class, use this syntax
		OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
	- Java program to demonstrate accessing a static nested class
	 
	// Outer class
	class OuterClass
	{ 
	    // static member
	    static int outer_x = 10;
	     
	    // instance(non-static) member
	    int outer_y = 20;
	     
	    // private member
	    private static int outer_private = 30;
	     
	    // static nested class
	    static class StaticNestedClass
	    {
	        void display()
	        {
	            // Can access static member of outer class
	            System.out.println("outer_x = " + outer_x);
	             
	            // can access private static member of outer class
	            System.out.println("outer_private = " + outer_private);
	             
	            // The following statement will give compilation error
	            // as static nested class cannot directly access non-static member
	            // System.out.println("outer_y = " + outer_y);
	         
	        }
	    }
	}
	 
	// Driver class
	public class StaticNestedClassDemo
	{
	    public static void main(String[] args)
	    {
	        // accessing a static nested class
	        OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
	         
	        nestedObject.display();
	         
	    }
	}
	
	Output:
	outer_x = 10
	outer_private = 30

----------------------------------------
Local Class
----------------------------------------
	- Rules of Local Inner Class:
	    a. The scope of local inner class is restricted to the block they are defined in.
    	b. Local inner class cannot be instantiated from outside the block where it is created in.
	    c. Till JDK 7, Local inner class can access only final local variable of the enclosing block. 
	       However from JDK 8, it is possible to access the non-final local variable of enclosing block in local inner class.
    	d. A local class has access to the members of its enclosing class.
	    e. Local inner classes can extend an abstract class or can also implement an interface. 
	- Declaring a Local Inner class
		- A local inner class can be declared within a block. 
		- This block can be either a method body, initialization block, for loop or even an if statement.
	- Accessing Members
		- A local inner class has access to fields of the class enclosing it as well as the fields of the block that it is defined within.
		- These classes, however, can access the variables or parameters of the block that encloses it only if they are declared as final or are effectively final. 
		- A variable whose value is not changed once initialized is called as effectively final variable. 
		- A local inner class defined inside a method body, have access to it’s parameters.
	- What happens at compile time?
		- When a program containing a local inner class is compiled, the compiler generate two .class files, 
		  one for the outer class and the other for the inner class that has the reference to the outer class. 
		- The two files are named by compiler as:
		    Outer.class
    		Outer$1Inner.class
    - Java program to demonstrate accessing an inner class
		 
		// Outer class
		class OuterClass
		{ 
		    // static member
		    static int outer_x = 10;
		     
		    // instance(non-static) member
		    int outer_y = 20;
		     
		    // private member
		    private int outer_private = 30;
		     
		    // inner class
		    class InnerClass
		    {
		        void display()
		        {
		            // can access static member of outer class
		            System.out.println("outer_x = " + outer_x);
		             
		            // can also access non-static member of outer class
		            System.out.println("outer_y = " + outer_y);
		             
		            // can also access private member of outer class
		            System.out.println("outer_private = " + outer_private);
		         
		        }
		    }
		}
		 
		// Driver class
		public class InnerClassDemo
		{
		    public static void main(String[] args)
		    {
		        // accessing an inner class
		        OuterClass outerObject = new OuterClass();
		        OuterClass.InnerClass innerObject = outerObject.new InnerClass();
		         
		        innerObject.display();
		    }
		}
		
		Output:
		outer_x = 10
		outer_y = 20
		outer_private = 30
    
    - Declaration within a method body
		// Java program to illustrate working of local inner classes
		public class Outer
		{
		    private void getValue()
		    {
		        // Note that local variable(sum) must be final till JDK 7 
		        // hence this code will work only in JDK 8
		        int sum = 20;
		         
		        // Local inner Class inside method
		        class Inner
		        {
		            public int divisor;
		            public int remainder;
		             
		            public Inner() {
		                divisor = 4;
		                remainder = sum%divisor;
		            }
		            
		            private int getDivisor() {
		                return divisor;
		            }
		            
		            private int getRemainder() {
		                return sum%divisor;
		            }
		            
		            private int getQuotient() {
		                System.out.println("Inside inner class");
		                return sum / divisor;
		            }
		        }
		         
		        Inner inner = new Inner();
		        System.out.println("Divisor = " + inner.getDivisor());
		        System.out.println("Remainder = " + inner.getRemainder());
		        System.out.println("Quotient = " + inner.getQuotient());
		    }
		     
		    public static void main(String[] args) {
		        Outer outer = new Outer();
		        outer.getValue();
		    }
		}
		
		Output:
		Divisor = 4
		Remainder = 0
		Inside inner class
		Quotient = 5

----------------------------------------
Anonymous Inner Class
----------------------------------------
	- It is an inner class without a name and for which only a single object is created. 
	- An anonymous inner class can be useful when making an instance of an object with 
	  certain “extras” such as overloading methods of a class or interface, without having to actually subclass a class.
	- Constructors can not be declared in an anonymous class
	- Accessing Members
		a. An anonymous class has access to the members of its enclosing class
   		b. An anonymous class cannot access local variables in its enclosing scope that are
   		   not declared as final or effectively final
   		c. Like a nested class, a declaration of a type (such as a variable) in an anonymous class 
   		   shadows any other declarations in the enclosing scope that have the same name
   		d. Cannot declare static initializers or member interfaces in an anonymous class
	- Can declare the following in anonymous classes
		a. Fields
    	b. Extra methods (even if they do not implement any methods of the supertype)
    	c. Instance initializers
    	d. Local classes
    	e. Static members provided that they are constant variables

	- Java program to demonstrate Anonymous inner class
		
		interface Age {
		    int x = 21;
		    void getAge();
		}
		
		class AnonymousDemo {
		
		    public static void main(String[] args) {
		        // An inner class of Age interface, whose name is not written but an object to it is created
		        Age age = new Age() {
		            @Override
		            public void getAge() {
		                System.out.print("Age is " + x);
		            }
		        };
		        age.getAge();
		    }
		}

-----------------------------------------------------------------------------------------------------------------------------
Generics
-----------------------------------------------------------------------------------------------------------------------------
https://www.javatpoint.com/generics-in-java

----------------------------------------
Before Java 5:
----------------------------------------
	// list can hold any Оbject
	List list = new ArrayList();
	 
	// String is Object
	list.add( "text" ); 
	 
	// Integer is also Object
	list.add( new Integer( 123 ) );
	 
	// Needs cast, but perfectly legal
	String text = (String) list.get( 0 ); 
 
	String moreText = (String) list.get( 1 ); // Run-Time:ClassCastException: Integer cannot be cast to String
	
In this example, Generics will help not only eliminate the Run-Time:ClassCastException, 
but it will also save you the trouble of casting to String.

----------------------------------------
After Java 5:
----------------------------------------
	// compiler will make sure the "list" reference can insert only Strings into its collection
	List<String> list = new ArrayList<String>(); 
	 
	// Perfectly legal
	list.add( "text" );
	 
	list.add( new Integer( 123 ) ); // Compile-Time:The method add(String) ... is not applicable for ... (Integer)
	
----------------------------------------
Type Parameters:
----------------------------------------
The common type parameters are as follows:
	T - Type
	E - Element
	K - Key
	N - Number
	V - Value

----------------------------------------
Creating generic class:
----------------------------------------
	public class MyGen<T>{  

		T obj;
		
		void add(T obj) {
			this.obj=obj;
		}

		T get() {
			return obj;
		}
		
	}

----------------------------------------
Using generic class:
----------------------------------------
	class TestGenerics3 {
	
		public static void main(String args[]) {
			MyGen<Integer> m=new MyGen<Integer>();
			m.add(2);
			//m.add("vivek"); //Compile time error
			System.out.println(m.get());
		}
		
	}

----------------------------------------
Generic methods/functions:
----------------------------------------
public class Test
{
    // A Generic method example
    public static <T> void genericDisplay (T element) {
        System.out.println(element.getClass().getName() + " = " + element);
    }
  
    // Driver method
    public static void main(String[] args) {
         // Calling generic method with Integer argument
        genericDisplay(11);
  
        // Calling generic method with String argument
        genericDisplay("GeeksForGeeks");
  
        // Calling generic method with double argument
        genericDisplay(1.0);
    }
}

----------------------------------------
Advantages:
----------------------------------------
	- Type-safety
		- We can hold only a single type of objects in generics. It doesn’t allow to store other objects.
	- Type casting is not required
		- There is no need to typecast the object.
	- Compile-Time checking
		- It is checked at compile time so problem will not occur at runtime. 
		- The good programming strategy says it is far better to handle the problem at compile time than runtime.

----------------------------------------
Disadvantages
----------------------------------------
- Still not 100% TypeSafe
	The funny thing is that the below code will actually compile successfully giving the developer a false sense of 
	security that wouldn’t last long, because the last line will fail at 
	Run-Time producing: java.lang.ClassCastException: java.lang.Object cannot be cast to java.lang.String.

	// create a Vector that will allow only String
	Vector<String> strings = new Vector<String>();
	 
	// perfectly legal
	strings.add( "a string" );
	 
	// cast the Vector to a generic Vector, by default generic vector allows Object
	Vector objects = strings;
	 
	// insert an Object into the Vector
	objects.add( new Object() );
	 
	// fetch an Object from the Vector of strings
	Object anObject = strings.get( 0 );
	 
	// fetch a String from the Vector of strings
	String aString = strings.get( 0 );
	
	
- Generics apply Type-Erasure internally. 
	- It basically takes all Generics declarations and replaces them with appropriate types.

For bounded types:
----------------------------------------

	public class Node<T> extends Comparable<T> {
	 
	    private T data;
	    private Node<T> next;
	 
	    public Node(T data, Node<T> next) {
	        this.data = data;
	        this.next = next;
	    }
	 
	    public T getData() { return data; }
	    // ...
	}

The Java compiler replaces the bounded type parameter “T” with the first bound class, Comparable:

	public class Node {
	 
	    private Comparable data;
	    private Node next;
	 
	    public Node(Comparable data, Node next) {
	        this.data = data;
	        this.next = next;
	    }
	 
	    public Comparable getData() { return data; }
	    // ...
	}
	
For unbounded types:
----------------------------------------

	public class Node<T> {
	 
	    private T data;
	    private Node<T> next;
	 
	    public Node(T data, Node<T> next) }
	        this.data = data;
	        this.next = next;
	    }
	 
	    public T getData() { return data; }
	    // ...
	}

Because the type parameter “T” is unbounded, the Java compiler replaces it with Object:

	public class Node {
	 
	    private Object data;
	    private Node next;
	 
	    public Node(Object data, Node next) {
	        this.data = data;
	        this.next = next;
	    }
	 
	    public Object getData() { return data; }
	    // ...
	}

-----------------------------------------------------------------------------------------------------------------------------
Input / Output
-----------------------------------------------------------------------------------------------------------------------------
Code to read input from keyboard?
	- BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
      String line = reader.readLine();
      System.out.println(line);
      
    - Scanner scanner = new Scanner(System.in);
      String str = scanner.nextLine();
      System.out.println(str);
	  scanner.close();

BufferedReader vs Scanner
	1. BufferedReader is synchronous while Scanner is not
	2. BufferedReader should be used if we are working with multiple threads
    3. BufferedReader (8KB char buffer) has significantly larger buffer memory than Scanner (1KB char buffer)
    4. BufferedReader is a bit faster as compared to scanner 
       because scanner does parsing of input data and BufferedReader simply reads sequence of characters

-----------------------------------------------------------------------------------------------------------------------------
# Threading:
-----------------------------------------------------------------------------------------------------------------------------
How to create threads?
	- Implement Runnable interface
		public class MyRunnable implements Runnable {
			@Override
			public void run() {
				for (int i = 0; i < 10; i++) {
					System.out.println(Thread.currentThread().getName() + " MyRunnable - run method..." + i);
				}
			}
		}
		
		public class TestThread {
			public static void main(String[] args) throws InterruptedException {
				System.out.println("---Start---");
				Thread t = new Thread(new MyRunnable());
				t.start();
				System.out.println("---End---");
			}
		}
			
	- Extend Thread class
		public class MyThread extends Thread {
			@Override
			public void run() {
				for (int i = 0; i < 10; i++) {
					System.out.println(Thread.currentThread().getName() + " MyThread - run method..." + i);
				}
			}
		}
		
		public class TestThread {
			public static void main(String[] args) throws InterruptedException {
				System.out.println("---Start---");
		
				Thread mt = new MyThread();
				mt.start();
		
				System.out.println("---End---");
			}
		}
			
Callable and Future
----------------------------------------
	Callable
	-----------------
		There are two ways of creating threads, one by extending the Thread class and other by creating a thread with a Runnable. 
		However, one feature lacking in  Runnable is that we cannot make a thread return result when it terminates, i.e. when run() completes. 
		For supporting this feature, the Callable interface is present in Java.		

	Future
	-----------------
		When the call() method completes, answer must be stored in an object known to the main thread, 
		so that the main thread can know about the result that the thread returned. 
		How will the program store and obtain this result later? 
		For this, a Future object can be used. 
		Think of a Future as an object that holds the result – it may not hold it right now, 
		but it will do so in the future (once the Callable returns). 
		Thus, a Future is basically one way the main thread can keep track of the progress and result from other threads. 
		To implement this interface, 5 methods have to be overridden.

	FutureTask
	-----------------
		To create the thread, a Runnable is required. To obtain the result, a Future is required.
		The Java library has the concrete type FutureTask, which implements Runnable and Future, combining both functionality conveniently.
		A FutureTask can be created by providing its constructor with a Callable. 
		Then the FutureTask object is provided to the constructor of Thread to create the Thread object. 
		Thus, indirectly, the thread is created with a Callable. 
		For further emphasis, note that there is no way to create the thread directly with a Callable.
		
	Callable vs Runnable
	-----------------
		For implementing Runnable, the run() method needs to be implemented which does not return anything, 
		while for a Callable, the call() method needs to be implemented which returns a result on completion. 
		Note that a thread can’t be created with a Callable, it can only be created with a Runnable.
	    Another difference is that the call() method can throw an exception whereas run() cannot.

	Callable method signature
	-----------------	
	public Object call() throws Exception;
	
	Runnable method signature
	-----------------
	public void run();
	
	Sample Code
	-----------------
	    public class MyCallable implements Callable {
		    public Object call() throws Exception {
		        // Create random number generator
		        Random generator = new Random();
		  
		        Integer randomNumber = generator.nextInt(5);
		  
		        // To simulate a heavy computation, we delay the thread for some random time
		        Thread.sleep(randomNumber * 1000);
		  
		        return randomNumber;
		    }
		}
		
		public class TestCallableFuture {
		  public static void main(String[] args) throws Exception {
		  
		    // FutureTask is a concrete class that implements both Runnable and Future
		    FutureTask[] randomNumberTasks = new FutureTask[5];
		  
		    for (int i = 0; i < 5; i++)
		    {
		      Callable callable = new MyCallable();
		  
		      // Create the FutureTask with Callable
		      randomNumberTasks[i] = new FutureTask(callable);
		  
		      // As it implements Runnable, create Thread with FutureTask
		      Thread t = new Thread(randomNumberTasks[i]);
		      t.start();
		    }
		  
		    for (int i = 0; i < 5; i++)
		    {
		      // As it implements Future, we can call get()
		      System.out.println(randomNumberTasks[i].get());
		  
		      // This method blocks till the result is obtained
		      // The get method can throw checked exceptions like when it is interrupted. 
		      // This is the reason for adding the throws clause to main
		    }
		  }
		}
	
	

How to make a class thread safe? What basic precautions should I take to make it thread safe.
Can a lock be acquired on a class?

What does the Java “synchronized” keyword do, and when do you use it?
* what happens when i make static method as synchronized?
can we synchronize a constructor in java?

What are some of the problems you can encounter with multi-threaded programming?
Is there an advantage to running a multi-threaded application on a single processor computer?
How could you get two threads to deadlock?
how do you find out deadlock has occurred in java?
what is thread leak in java?
What is a difference between a thread and a process?
difference btw sleep, suspend & wait?
How can u make a thread daemon?
What are some common problems you have faced in multi-threading environment? How did you resolve it?
1) You have thread T1, T2 and T3, how will you ensure that thread T2 run after T1 and thread T3 run after T2?

Programming Problems
-----------------------------------------------------------------------------------------------------------------------------
Given a singly linked list find the 5th-to-last element. 
Write a function that inverts a string in place.

Coding Standards
-----------------------------------------------------------------------------------------------------------------------------
What are the general guidelines while doing a code review?
What is Functions Indention?
What is the standard naming convention used for constants?

Junit
-----------------------------------------------------------------------------------------------------------------------------
What is JUnit?
Why Do You Use JUnit to Test Your Code?
What are the Assertion Methods Supported by JUnit?
How do I test private methods using JUnit?   
dbunits

SVN/GIT
-----------------------------------------------------------------------------------------------------------------------------
How to use SVN or GIT? command line of ide?
What is the difference between branch and tag?

CSS
-----------------------------------------------------------------------------------------------------------------------------
What is the difference between div vs. span?
What is the difference between visiblity:hidden and display:none?
What are nth selector css classes?
What is the importance of exclamation important in css?
What is the difference between an ID selector and CLASS?
What are pseudo classes?

Ajax
-----------------------------------------------------------------------------------------------------------------------------
What is the difference between synchronous and asynchronous requests?
How do you upload a file using ajax?
How many types of ready states in Ajax?

jQuery
-----------------------------------------------------------------------------------------------------------------------------
What is the difference between jQuery and dollar sign?
	- '$' symbol is just an alias to "jQuery"
	- $(selector).action();
		- $ 		->	Sign denotes jQuery funciton
		- selector 	-> 	Select the HTML element
		- action()	-> 	Perform action on selected element
	- Eg:
		jQuery("p").hide();
		$("p").hide();

What is jQuery.noConflict()?
	- This method releases jQuery's control of the $ variable. 
	- This method can also be used to specify a new custom name for the jQuery variable. 
	- Tip: This method is useful when other JavaScript libraries use the $ for their functions.
	
Is window.onload is different from document.ready()?
	- window.onload is the built-in JavaScript event, but as its implementation had subtle quirks across browsers
	- jQuery provides document.ready, fires as soon as the page's DOM is ready (doesn't wait for images, etc.)
	- The ready event occurs after the HTML document has been loaded, 
	  while the onload event occurs later, when all content (e.g. images) also has been loaded.

What is the difference between jQuery empty() vs remove()? 
	- .empty(): 
		This method removes all the child element of the matched element.
	- .remove(): 
		This method takes elements out of the DOM. 
		Use .remove() when you want to remove the element itself, as well as everything inside it.
		In addition to the elements themselves, all bound events and jQuery data associated with the elements are removed. 
	- .detach(): 
		This method is the same as .remove(), except that .detach() keeps all jQuery data associated with the removed elements. 
		This method is useful when removed elements are to be reinserted into the DOM at a later time.

Code
-----------------------------------------------------------------------------------------------------------------------------
public static int testException() {
		try {
			System.out.println("Starting ");
			int value = 3 + 6;
			int x = 3;
			value = value / x;
			System.out.println("Inside end " + value);
			return value;
		} catch (Exception e) {
			System.out.println("Inside exception ");
			return 0;
		} finally {
			return 10;
		}
}

Security
-----------------------------------------------------------------------------------------------------------------------------
Have you worked in security aspect of your Java EE application? How to handle XSS and CSRF?

Use cases
-----------------------------------------------------------------------------------------------------------------------------
Have you ever involved in debugging of a Java EE application?
The application is performing good, but most of the times it experiences splices in CPU and RAM usage; what could be the reason? how do you want to debug?
How do you write a thread-safe java class?

ClassNotFoundException Vs NoClassDefFoundError
-----------------------------------------------------------------------------------------------------------------------------
ClassNotFoundException is an exception that occurs when you try to load a class at run time using Class.forName() or loadClass() methods 
and mentioned classes are not found in the classpath. 

NoClassDefFoundError is an error that occurs when a particular class is present at compile time, but was missing at run time





Callable vs Runnable

    For implementing Runnable, the run() method needs to be implemented which does not return anything.
    While for a Callable, the call() method needs to be implemented which returns a result on completion. 
    Note that a thread can’t be created with a Callable, it can only be created with a Runnable.
    Another difference is that the call() method can throw an exception whereas run() cannot.
------------------------------------------------------------------------------------------
Index
------------------------------------------------------------------------------------------
1. Spring Framework
2. Spring AOP
3. Spring MVC
4. Spring Security
5. Spring Transaction
6. Spring DAO
7. Spring ORM
8. Spring JDBC
9. Spring Data
10. Spring Boot

------------------------------------------------------------------------------------------
Spring
------------------------------------------------------------------------------------------
What is your experience in Spring?
	- 10 Years

What is Spring?
	- Spring is an open development framework for enterprise Java.

What are benefits of using spring?
	1. Lightweight: 
		Spring is lightweight when it comes to size and transparency. The basic version of spring framework is around 2MB.
	2. Inversion of control (IOC): 
		Loose coupling is achieved in spring using the technique Inversion of Control. 
		The objects give their dependencies instead of creating or looking for dependent objects.
	3. Aspect oriented (AOP): 
		Spring supports Aspect oriented programming and enables cohesive development 
		by separating application business logic from system services.
	4. Container: 
		Spring contains and manages the life cycle and configuration of application objects.
	5. MVC Framework: 
		Spring's web framework is a well-designed web MVC framework, 
		which provides a great alternative to web frameworks such as Struts or other over engineered or less popular web frameworks.
	6. Transaction Management: 
		Spring provides a consistent transaction management interface that can scale down to a local transaction 
		(using a single database, for example) and scale up to global transactions (using JTA, for example).
	7. Exception Handling: 
		Spring provides a convenient API to translate technology-specific exceptions 
		(thrown by JDBC, Hibernate, or JDO, for example) into consistent, unchecked exceptions.

What are the different modules in Spring framework?
    - Following are the modules of the Spring framework
        1. Core module
        2. Spring Context
        3. Spring AOP
        4. Spring DAO
        5. Spring ORM
        6. Spring Web (provides contexts for Web-based applications)
        7. Spring MVC Framework (full-featured MVC implementation for building Web applications)

What is Spring configuration file?
	- Spring configuration file is an XML file. 
	- This file contains the classes information and describes how these classes are configured and introduced to each other.

What is dependency injection?
	- Dependency Injection is one of the concrete examples of Inversion of Control.
	- Inversion of Control (IoC) is a general concept. It can be expressed in many different ways.
	- This concept says that you do not create your objects but describe how they should be created. 
	  You don't directly connect your components and services together in code but describe which services are needed 
	  by which components in a configuration file. 
	  A container (the IOC container) is then responsible for hooking it all up.

What are the different types of IoC (dependency injection)?
	Types of IoC are:
		1. Constructor dependency injection
		2. Setter dependency injection

Which DI would you suggest Constructor-based or setter-based DI?
	- Use constructor arguments for mandatory dependencies and setters for optional dependencies. 
	- Note that the use of a @Required annotation on a setter can be used to make setters required dependencies.

What is Spring IoC container?
	- It creates the objects, wire them together, configure them and manage their complete lifecycle from creation till destruction. 
	- The Spring container uses dependency injection (DI) to manage the components that make up an application.
	
What are types of IoC containers? 
    1. BeanFactory (XmlBeanFactory)
    2. ApplicationContext (FileSystemXmlApplicationContext, ClassPathXmlApplicationContext)
        a. AbstractApplicationContext (registerShutdownHook())
    3. WebApplicationContext (WebXmlApplicationContext)

What is Bean Factory?
    Is the one which manages the life cycle of beans (including dependency injection) for standalone applications.

What is Application Context?
    It is same as a bean factory, but it provides additional functionalities like:
        a. A means for resolving text messages, including support for internationalization.
        b. A generic way to load file resources.
        c. Publish events to beans that are registered as listeners.

What is the difference between Bean Factory and Application Context ?  
    On the surface, an application context is same as a bean factory. But application context offers much more..
        a. AC provide a means for resolving text messages, including support for i18n of those messages.
        b. AC provide a generic way to load file resources, such as images.
        c. AC can publish events to beans that are registered as listeners.
        d. Certain operations on the container or beans in the container, 
            which have to be handled in a programmatic fashion with a bean factory, can be handled declaratively in an application context.
        e. ResourceLoader support: 
            An application context itself is a ResourceLoader. 
            Hence provides access to deployment-specific Resource instances.
        f. MessageSource support: 
            The application context implements MessageSource, an interface used to obtain localized messages

What are Spring beans?
	- Objects that are managed by the Spring IoC container are called beans.
	- A bean is an object that is instantiated, assembled and otherwise managed by a Spring IoC container.

What are spring bean scopes?
    1. singleton
        - This scopes the bean definition to a single instance per Spring IoC container.
        - Default scope in spring
        - Singleton beans are not thread-safe in Spring framework.
    2. prototype: This scopes a single bean definition to have any number of object instances.
    3. request: This scopes a bean definition to an HTTP request. Only valid in the context of a web-aware Spring ApplicationContext.
    4. session: This scopes a bean definition to an HTTP session. Only valid in the context of a web-aware Spring ApplicationContext.
    5. global-session: This scopes a bean definition to a global HTTP session. Only valid in the context of a web-aware Spring ApplicationContext.

What is the difference between spring singleton and java singleton?
    - Spring singleton ensures only one instance per Spring container.
    - Java singleton ensures only one instance per JVM/class loader.

Explain Bean lifecycle in Spring framework?
	Following is sequence of a bean lifecycle in Spring:
	1. Instantiate 
		- First the spring container finds the bean's definition from the XML file and instantiates the bean.
	2. Populate properties 
		- Using the dependency injection, spring populates all of the properties as specified in the bean definition.
	3. Set Bean Name 
		- If the bean implements BeanNameAware interface, spring passes the bean's id to setBeanName() method.
	4. Set Bean factory 
		- If Bean implements BeanFactoryAware interface, spring passes the beanfactory to setBeanFactory() method.
	5. Pre Initialization 
		- Also called postprocess of bean. If there are any bean BeanPostProcessors associated with the bean, 
		  Spring calls postProcesserBeforeInitialization() method.
	6. Initialize beans 
		- If the bean implements IntializingBean, its afterPropertySet() method is called. 
		- If the bean has init method declaration, the specified initialization method is called.
	7. Post Initialization 
		- If there are any BeanPostProcessors associated with the bean, their postProcessAfterInitialization() methods will be called.
	8. Ready to use 
		- Now the bean is ready to use by the application.
	9. Destroy 
		- If the bean implements DisposableBean, it will call the destroy() method .

What do you mean by Bean wiring ?
    The act of initializing bean with a dependent bean.

What do you mean by Auto Wiring?
	- Automatically initializing the bean with the dependent bean, 
	  by inspecting the contents of the BeanFactory without using <constructor-arg> and <property> elements.

What are different Modes of auto wiring?
	The autowiring functionality has five modes which can be used to instruct Spring container to use autowiring for dependency injection:
	1. no: This is default setting which means no autowiring and you should use explicit bean reference for wiring. 
	2. byName: Autowiring by property name. 
	3. byType: Autowiring by property datatype. If more than one such beans exist, a fatal exception is thrown.
	4. constructor: Similar to byType, but type applies to constructor arguments. 
	                If there is no bean of the constructor argument type in the container, a fatal error is raised.
	5. autodetect: Spring first tries to wire using autowire by constructor.
	               If it does not work, Spring tries to autowire by byType.

Can you inject null and empty string values in Spring?
	- Yes

Spring configurations:
    1. <context:component-scan base-package="com.java.test.domain" />
       <context:component-scan base-package="com.java.test.dto" />
        - To scan the classes for dependency injection
        
    2. <context:spring-configured />
        - Apply DI to non-managed classes in Spring

    3. <context:annotation-config/> 
        - Turns on annotation wiring
        Activates various annotations to be detected in bean classes: 
        Spring's @Required and @Autowired
        JSR 250's @PostConstruct, @PreDestroy and @Resource (if available)
        JAX-WS's @WebServiceRef (if available)
        EJB3's @EJB (if available)
        JPA's @PersistenceContext and @PersistenceUnit (if available). 
    Alternatively, you may choose to activate the individual BeanPostProcessors for those annotations. 
    Note: This tag does not activate processing of Spring's @Transactional or EJB3's @TransactionAttribute annotation. 
    Consider the use of the <tx:annotation-driven> tag for that purpose.

    4. <tx:annotation-driven transaction-manager="testTransactionManager" mode="aspectj"/>
        - Configures @Transactional

    5. <aop:aspectj-autoproxy proxy-target-class="true" />
        - Enables the use of the @AspectJ style of Spring AOP.
        
    6. <task:annotation-driven executor="testTaskExecutor" />
        - Enables the detection of @Async and @Scheduled annotations on any Spring-managed object. 
        - If present, a proxy will be generated for executing the annotated methods asynchronously. 

    7. <task:executor id="testTaskExecutor" pool-size="25"/>
        - Defines a ThreadPoolTaskExecutor instance with configurable pool size, queue-capacity, keep-alive and rejection-policy values

    8. <mvc:annotation-driven />
        - Configures the annotation-driven Spring MVC Controller programming model.
    
    9. <mvc:default-servlet-handler />
        - Configures a handler for serving static resources by forwarding to the Servlet container's default Servlet. 
        - Use of this handler allows using a "/" mapping with the DispatcherServlet while still utilizing the Servlet 
          container to serve static resources.

Describe some of the standard Spring events.
	Spring provides the following standard events:
	1. ContextRefreshedEvent: 
	   	This event is published when the ApplicationContext is either initialized or refreshed. 
	   	This can also be raised using the refresh() method on the ConfigurableApplicationContext interface.
	2. ContextStartedEvent: 
		This event is published when the ApplicationContext is started using the start() method on the ConfigurableApplicationContext interface. 
		You can poll your database or you can re/start any stopped application after receiving this event.
	3. ContextStoppedEvent: 
		This event is published when the ApplicationContext is stopped using the stop() method on the ConfigurableApplicationContext interface. 
		You can do required housekeep work after receiving this event.
	4. ContextClosedEvent: 
		This event is published when the ApplicationContext is closed using the close() method on the ConfigurableApplicationContext interface. 
		A closed context reaches its end of life; it cannot be refreshed or restarted.
	5. RequestHandledEvent: 
		This is a web-specific event telling all beans that an HTTP request has been serviced.

------------------------------------------------------------------------------------------
Spring AOP
------------------------------------------------------------------------------------------
What is AOP?
    AOP is a programming technique that allows programmers to address cross-cutting concerns
     across the application, such as logging and transaction management.
     
What is Aspect?
	- A module which has a set of APIs providing cross-cutting requirements. 
	- For example, a logging module would be called AOP aspect for logging. 
	- An application can have any number of aspects depending on the requirement. 
	- In Spring AOP, aspects are implemented using regular classes (the schema-based approach) 
	  or regular classes annotated with the @Aspect annotation (@AspectJ style).

What is the difference between concern and cross-cutting concern in Spring AOP?
	- Concern: 
		Concern is a behavior in a module of an application. 
		Concern may be defined as a functionality we want to implement. 
	- Cross-cutting concern: 
		It's a concern which is applicable throughout the application and it affects the entire application. 
		e.g. logging, security and data transfer are the concerns which are needed in almost every module of an application.

What is Join point?
	- Represents a point in your application where you can plug-in AOP aspect. 
	- You can also say, it is the actual place in the application where an action will be taken using Spring AOP framework.

What is Advice?
	- This is the actual action to be taken either before or after the method execution. 
	- This is actual piece of code that is invoked during program execution by Spring AOP framework.

Types of Advice?
    1. before: Run advice before the method execution.
	2. after: Run advice after the method execution regardless of its outcome.
	3. after-returning: Run advice after the method execution only if method completes successfully.
	4. after-throwing: Run advice after the method execution only if method exits by throwing an exception.
	5. around: Run advice before and after the advised method is invoked.

What is Pointcut?
	- This is a set of one or more joinpoints where an advice should be executed. 
	- You can specify pointcuts using expressions or patterns as we will see in our AOP examples.

What is Weaving?
	- Weaving is the process of linking aspects with other application types or objects to create an advised object.

What are the different points where weaving can be applied?
    - Weaving can be done at 
        a. compile time
        b. load time
        c. runtime
        
    ---------------------------------------
    Custom Aspect Class
    ---------------------------------------
	@Aspect
	public class LoggingAspect {
	
		// =================================================
		// Join Points 
		// 1. Represents a point in your application where you can plug-in AOP aspect. 
		// 2. You can also say, it is the actual place in the application where an action will be taken using Spring AOP framework.
		//
		// Pointcut
		// 1. This is a set of one or more joinpoints where an advice should be executed. 
		// 2. You can specify pointcuts using expressions or patterns as we will see in our AOP examples.

		// =================================================
		/**
		 * This is the point cut for all controller classes which will be used for logging method entry and exit.
		 */
		@Pointcut("within(@org.springframework.stereotype.Controller *)")
		public void controllerLoggingPointcut() {}
	
		/**
		 * This is the point cut for all service classes which will be used for logging method entry and exit.
		 */
		@Pointcut("within(@org.springframework.stereotype.Service *)")
		public void serviceLoggingPointcut() {}
	
		/**
		 * This is the point cut for all adapter classes which will be used for logging method entry and exit.
		 */
		@Pointcut("execution(* *..service.adapter..*(..))")
		public void adapterLoggingPointcut() {}
	
		/**
		 * All public methods
		 */
		@Pointcut("execution(public * com.java..*(..))")
		public void allMethodsPointcut() {}
	
		// =================================================
		// Advice
		// 1. This is the actual action to be taken either before or after the method execution. 
		// 2. This is actual piece of code that is invoked during program execution by Spring AOP framework.
		// =================================================
		/**
		 * Logging method for all controller classes.
		 * @param joinPoint
		 * @return Object
		 * @throws Throwable
		 */
		@Around("controllerLoggingPointcut() && allMethodsPointcut()")
		public Object doLoggingForControllers(ProceedingJoinPoint joinPoint) throws Throwable {
			return log(joinPoint, Level.INFO);
		}
	
		/**
		 * Logging method for all service Classes
		 * @param joinPoint
		 * @return Object
		 * @throws Throwable
		 */
		@Around("serviceLoggingPointcut() && allMethodsPointcut()")
		public Object doLoggingForService(ProceedingJoinPoint joinPoint) throws Throwable {
			return log(joinPoint, Level.INFO);
		}
	
		/**
		 * Logging method for all adapter Classes.
		 * @param joinPoint
		 * @return Object
		 * @throws Throwable
		 */
		@Around("adatperLoggingPointcut() && allMethodsPointcut()")
		public Object doLoggingForAdapter(ProceedingJoinPoint joinPoint) throws Throwable {
			return log(joinPoint, Level.INFO);
		}
	
		// =================================================
		// Private Methods
		// =================================================
		/**
		 * Used to log the messages
		 * @param proceedingJoinPoint
		 * @param logLevel
		 * @return Object
		 * @throws Throwable
		 */
		private Object log(final ProceedingJoinPoint proceedingJoinPoint, Level logLevel) throws Throwable {
			final StopWatch stopWatch = new StopWatch();
			stopWatch.start();
			final String aClassName = proceedingJoinPoint.getSignature().getDeclaringType().getSimpleName();
			final String aMethodName = proceedingJoinPoint.getSignature().getName();
			Object aReturnValue = null;
			if (null != logLevel) {
				LOGGER.log(logLevel, LogFormatUtil.infoFormat("ENTERED_METHOD", aClassName + "." + aMethodName + "()"));
				try {
					aReturnValue = proceedingJoinPoint.proceed();
				} catch (Exception exception) {
					stopWatch.stop();
					LOGGER.log(logLevel, LogFormatUtil.infoFormat("EXITED_METHOD", aClassName + "." + aMethodName + "()", "TIME", stopWatch.getTime()));
					LOGGER.error(LogFormatUtil.exceptionFormat(exception.getMessage()));
					throw exception;
				}
				stopWatch.stop();
				LOGGER.log(logLevel, LogFormatUtil.infoFormat("EXITED_METHOD", aClassName + "." + aMethodName + "()", "RESPONSE_TIME", stopWatch.getTime()));
			} else {
				aReturnValue = proceedingJoinPoint.proceed();
			}
			return aReturnValue;
		}
	}

AOP Expressions (Spring PCD - Spring Pointcut Designators)
------------------------------------------------------------------------------------------
	1. "execution(public String com.mk.myblog.service.UserService.fetchAll())"
	   "execution(* * com.mk.myblog.service..*(..))"
	
	2. "within(com.mk.myblog.service.UserService)"
	   "within(com.mk..*)" -> Within the package or sub-packages
	
	3. "@within()"
			- This PCD limits matching to join points within types that have the given annotation:
			- @Pointcut("@within(org.springframework.stereotype.Repository)")
			- @Pointcut("within(@org.springframework.stereotype.Repository *)")
	
	4. this and target
		- Eg:
			public class FooDao implements BarDao {
		 	   ...
			}
		- 'this' limits matching to join points where the bean reference is an instance of the given type.
			- @Pointcut("this(com.baeldung.pointcutadvice.dao.FooDao)")
		- 'target' limits matching to join points where the target object is an instance of the given type.
			- @Pointcut("target(com.baeldung.pointcutadvice.dao.BarDao)")
			
	5. "@target()"
			- @target PCD limits matching to join points where the class of the executing object has an annotation of the given type
			- Pointcut("@target(org.springframework.stereotype.Repository)")
			
	6. "@args"
			- @Pointcut("execution(* *..find*(Long))")
			- @Pointcut("execution(* *..find*(Long,..))")
	

------------------------------------------------------------------------------------------
Spring MVC
------------------------------------------------------------------------------------------
What is a DispatcherServlet?
	- It handles all the HTTP requests and responses.
	- It is a Front controller.
	- The Spring Web MVC framework is designed around a DispatcherServlet.

What is Controller in Spring MVC framework?
	- Controllers interpret user input and transform it into a model that is represented to the user by the view. 
	- Controllers provide access to the application behavior that you typically define through a service interface. 
	- Spring implements a controller in a very abstract way, which enables you to create a wide variety of controllers.

How Spring client converts DTO to xml/json?
	- Using message converters
	<bean id="jsonHttpMessageConverter" class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">
		<property name="prefixJson" value="false" />
		<property name="supportedMediaTypes" value="application/*" />
		<property name="objectMapper" ref="jacksonObjectMapper" />
	</bean>
	
	<bean id="jacksonObjectMapper" class="com.fasterxml.jackson.databind.ObjectMapper" />
	
How a method in controller is getting invoked when user hit on submit button?
	1. Handler level mapping
		Following are the different mapping types supported.
			a. By path
				@RequestMapping("path")
			b. By HTTP method
				@RequestMapping("path", method=RequestMethod.GET)
				Other Http methods such as POST, PUT, DELETE, OPTIONS, and TRACE are also supported.
			c. By query parameter
				@RequestMapping("path", method=RequestMethod.GET, params="param1")
			d. By presence of request header
				@RequestMapping("path", header="content-type=text/*")
				
	2. Mapping at Controller class level
		@RequestMapping("/employee/*")
		public class Employee {

Circular/Cyclic dependency in spring and how to resolve it?
    In Spring, beans are instantiated first, then injected into each other.
    There are many ways to deal with circular dependencies in Spring.
    The first thing to consider is to redesign your beans so there is no need for circular dependencies
    But if we absolutely need to have circular dependencies in our project, then we can follow some of the following workarounds.

The preferred method is using setter injections.
http://www.baeldung.com/circular-dependencies-in-spring
    
    - Solution 1: Use setter-injection
        @Component
        public class ClassA {
         
            private ClassB classB;
         
            @Autowired
            public void setClassB(ClassB classB) {
                this.classB = classB;
            }
         
            public ClassB getClassB() {
                return classB;
            }
        }
        
        @Component
        public class ClassB {
         
            private ClassA classA;
         
            @Autowired
            public void setClassA(ClassA classA) {
                this.classA = classA;
            }
         
            public ClassA getClassA() {
                return classA;
            }
        }
    --------------------------------------------------------------------------------------
    - Solution 2: Use field-injection
        @Component
        public class ClassA {
         
            @Autowired
            private ClassB classB;
         
        }
        
        @Component
        public class ClassB {
        
             @Autowired
            private ClassA classA;
         
        }
    --------------------------------------------------------------------------------------
    - Solution 3 - Use @Lazy
        Spring container will create a proxy to inject it into the other bean. 
        The injected bean will only be fully created when it’s first needed.
        
        @Component
        public class ClassA {
         
            private ClassB classB;
         
            @Autowired
            public ClassA(@Lazy ClassB classB) {
                this.classB = classB;
            }
        }
    --------------------------------------------------------------------------------------        
    - Solution 4 - Use @PostConstruct
        Inject a dependency using @Autowired on one of the beans, 
        and then use a method annotated with @PostConstruct to set the other dependency.
        
        @Component
        public class ClassA {
         
            @Autowired
            private ClassB classB;
         
            @PostConstruct
            public void init() {
                classB.setClassA(this);
            }
        }
        
        @Component
        public class ClassB {
         
            private ClassA classA;
            
            public void setClassA(ClassA classA) {
                this.classA = classA;
            }
        }
    --------------------------------------------------------------------------------------        
    - Solution 5: Implement ApplicationContextAware and InitializingBean
        If one of the beans implements ApplicationContextAware, the bean has access to Spring context and can extract the other bean from there.
        Implement InitializingBean and manually set our dependency.
        
        @Component
        public class ClassA implements ApplicationContextAware, InitializingBean {
         
            private ClassB classB;
         
            private ApplicationContext context;
                  
            @Override
            public void setApplicationContext(final ApplicationContext ctx) throws BeansException {
                context = ctx;
            }
            
            @Override
            public void afterPropertiesSet() throws Exception {
                classB = context.getBean(ClassB.class);
            }
        }
        
        @Component
        public class ClassB {
         
            private ClassA classA;
         
            @Autowired
            public void setClassA(ClassA classA) {
                this.classA = classA;
            }
        }
    --------------------------------------------------------------------------------------        
    - Solution 6: 
        If you use constructor-injection and don't want to switch to setter-injection 
          then Spring's 'lookup-method-injection' will let one bean lazily lookup the other and hence workaround the cyclic dependency.

         <?xml version="1.0" encoding="UTF-8"?>
         <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
         
            <bean id="pizzaShop" class="com.javarticles.spring.PizzaShop">
                <lookup-method name="makePizza" bean="pizza"/>
                <lookup-method name="makeVeggiePizza" bean="veggiePizza"/>
            </bean>
             
            <bean id="pizza" class="com.javarticles.spring.Pizza" scope="prototype"/>
             
            <bean id="veggiePizza" class="com.javarticles.spring.Pizza" scope="prototype">
                <property name="isVeg" value="true"/>
            </bean>
        </beans>
    --------------------------------------------------------------------------------------
    - Solution 7:
        Add 'default-lazy-init="true"' to the application config xml file:
        
        <beans default-lazy-init="true" 
            xmlns="http://www.springframework.org/schema/beans"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xmlns:context="http://www.springframework.org/schema/context"
               xsi:schemaLocation="
                   http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
                   http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd >
            ...
            ...
        </bean>

------------------------------------------------------------------------------------------
Spring Security
------------------------------------------------------------------------------------------
http://www.concretepage.com/interview/spring-interview/interview-questions-spring-security
https://www.dineshonjava.com/spring-security-interview-questions-and-answers/

1. Which filter class is needed for spring security?
    - DelegatingFilterProxy

	------------------------
    web.xml
    ------------------------
    <filter>
        <filter-name>springSecurityFilterChain</filter-name>
        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>springSecurityFilterChain</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
    
    - For servlet 3, we can define AbstractSecurityWebApplicationInitializer. 
    ------------------------
    security-context.xml
    ------------------------
    <bean id="springSecurityFilterChain" class="org.springframework.security.web.FilterChainProxy">
		<constructor-arg>
			<list>
				<sec:filter-chain pattern="/**/jsondoc**" filters="none" />
				<sec:filter-chain pattern="/services/test/user" filters="testLogFilter,authenticationFilter" />
				<sec:filter-chain pattern="/services/verifications**" filters="requestLogFilter" />
			</list>
		</constructor-arg>
	</bean>

    ------------------------
	Custom Filter Class
    ------------------------
    @Component(value = "authenticationFilter")
	public class AuthenticationFilter implements Filter {
		
		@Autowired
		@Qualifier("appProperties")
		private PropertiesConfiguration appProperties;
		
		@Override
		public void init(FilterConfig filterConfig) throws ServletException {}
		
		public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
			final HttpServletRequest httpRequest = (HttpServletRequest) request;
			final HttpServletResponse httpResponse = (HttpServletResponse) response;
			...
			// If authentication fails, sendError()
		}
	
		@Override
		public void destroy() {}
		
		private void sendError(HttpServletRequest request, HttpServletResponse response, String errorMsg, String logMsg) throws IOException {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED, errorMsg);
			LOGGER.error(LogFormatUtil.errorFormat("Invalid request [" + request.getContextPath() + "," + request.getRemoteHost() + "]. " + logMsg));
		}
	
	}

2. What is the delegating filter proxy?
    - Is the one which provides the link between web.xml and the application context

3. What is the security filter chain?
    - Is the one which manages web security beans
    - FilterChainProxy lets us add a single entry to web.xml and deal entirely with the application context file for managing the web security beans.
    <bean id="filterChainProxy" class="org.springframework.security.web.FilterChainProxy">
        <constructor-arg>
            <list>
                <sec:filter-chain pattern="/restful/**" filters="securityContextPersistenceFilterWithASCFalse,basicAuthenticationFilter,exceptionTranslationFilter,filterSecurityInterceptor" />
                <sec:filter-chain pattern="/**" filters="securityContextPersistenceFilterWithASCTrue,formLoginFilter,exceptionTranslationFilter, filterSecurityInterceptor" /> 
            </list>
        </constructor-arg>
    </bean>

4. Why do you need the intercept-url?
    - Intercept-url element is used to define the set of URL patterns, to configure how they should be handled. 
        <intercept-url pattern='/secure/**' access='ROLE_A,ROLE_B'/>

5. In which order do you have to write multiple intercept-url’s?
    - Most specific patterns should come first and the most general should come last.
    <intercept-url pattern='/secure/a/**' access='ROLE_A'/>
    <intercept-url pattern='/secure/b/**' access='ROLE_B'/>
    <intercept-url pattern='/secure/**' access='ROLE_USER'/>

6. Is security a cross cutting concern?
    Yes, Spring Security is a cross cutting concern.

7. How security is implemented internally?
    Spring security uses Spring AOP internally.

8. What is a security context?
    Security context is the one which can provide details of the user/principal currently using the application.

9. How is a Principal defined?
    Spring Security uses an Authentication object to represent this information.

    Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
    if (principal instanceof UserDetails) {
        String username = ((UserDetails)principal).getUsername();
    } else {
        String username = principal.toString();
    }
    
10. What is authentication and authorization? Which must come first?
    Authentication – Checks whether user's credentials are valid
    Authorization – Checks if the user is allowed to perform an action
    
    Authentication comes first before Authorization (because authorization process needs principal object)

------------------------------------------------------------------------------------------
Spring Transaction
------------------------------------------------------------------------------------------
https://docs.spring.io/spring/docs/current/spring-framework-reference/html/transaction.html

1. Global vs Local transactions?
    - Global transaction works with multiple resources (typically relational databases and message queues)
        The application server manages global transactions through the JTA
        Need to use JNDI in order to use JTA
        Would limit the reuse of application code
    - Local transaction works with a specific resource (such as a transaction associated with a JDBC connection)
        Cannot run within a global JTA transaction (Because the application server is not involved in transaction management)
        Local transactions are invasive to the programming model.

Note: Spring resolves the disadvantages of global and local transactions. 

2. Types of the transaction management Spring supports
    Programmatic transaction management
    Declarative transaction management

3. Benefits of the Spring Framework transaction management
    Provides a consistent programming model across different transaction APIs such as JTA, JDBC, Hibernate, JPA, and JDO.
    Supports declarative transaction management.
    Provides a simpler API for programmatic transaction management than a number of complex transaction APIs such as JTA.
    Integrates very well with Spring's various data access abstractions.

4. Why most users of the Spring Framework choose declarative transaction management?
    Because it separates the business logic from the transaction specific logic

5. When to use programmatic and declarative transaction management ?
    Programmatic transaction management can be used if you have a small number of transactional operations
    Declarative transaction management is used if you have numerous transactional operations
        To keep transaction management out of business logic 

6. How Spring transaction works?

------------------------------------------------------------------------------------------
Spring DAO
------------------------------------------------------------------------------------------
Spring-DAO is not a spring module, but rather conventions
It does neither provide interfaces nor implementations nor templates to access your data
You should need to annotate them with @Repository
 [So that exceptions linked to the underlying technology (JDBC, Hibernate, JPA, etc.)
    are consistently translated into the proper DataAccessException subclass]

1. Explain about the Spring DAO support?
    DAO support is used to work with data access technologies like JDBC, Hibernate or JDO in a consistent way. 
    It allows to switch between the persistence technologies fairly easily.
    It also allows one to code without worrying about catching exceptions that are specific to each technology.

2. What are the exceptions thrown by the Spring DAO classes?
    Spring DAO classes throw exceptions which are subclasses of DataAccessException(org.springframework.dao.DataAccessException).
    Spring provides a translation from technology-specific exceptions like SQLException to its own exception class hierarchy 
    with the DataAccessException as the root exception. 
    These exceptions wrap the original exception.

------------------------------------------------------------------------------------------
Spring ORM
------------------------------------------------------------------------------------------
The Spring Framework supports integration with Hibernate, JPA and Java Data Objects (JDO) for resource management, 
data access object (DAO) implementations, and transaction strategies.

1. What are the ORM’s Spring supports?
    JPA (Java Persistence API)
    Hibernate
    iBatis
    TopLink
    JDO (Java Data Objects)
    OJB

2. What are the ways to access Hibernate using Spring?
    Two approaches to Spring’s Hibernate integration:
        a. Inversion of Control with a HibernateTemplate and Callback
        b. Extending HibernateDaoSupport and applying an AOP Interceptor 

3. How to integrate Spring and Hibernate using HibernateDaoSupport?
    Spring and Hibernate can integrate using Spring's SessionFactory called LocalSessionFactory. 
    The integration process is of 3 steps.
	    ---------------------------------------
        a. Configure datasource
        ---------------------------------------
        	<!-- JNDI Data Source -->
			<bean id="usiDataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
				<property name="jndiName" value="jdbc/TestDatasource" />
				<property name="resourceRef" value="true" />
			</bean>
        
        ---------------------------------------
        b. Configure Hibernate SessionFactory
        ---------------------------------------
        	<!-- Session Factory -->
        	<bean id="testSessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean" lazy-init="false">
				<property name="dataSource" ref="testDataSource" />
				<property name="hibernateProperties">
					<props>
						<prop key="hibernate.dialect">org.hibernate.dialect.Oracle10gDialect</prop>
						<prop key="hibernate.show_sql">false</prop>
						<prop key="hibernate.hbm2ddl.auto">none</prop>
						<prop key="hibernate.max_fetch_depth">2</prop>
						<prop key="hibernate.default_batch_fetch_size">16</prop>
						<prop key="hibernate.jdbc.batch_size">30</prop>
						<prop key="hibernate.order_inserts">true</prop>  
						<prop key="hibernate.order_updates">true</prop> 
						<prop key="hibernate.connection.release_mode">auto</prop>
						<prop key="hibernate.cache.use_second_level_cache">false</prop>
					</props>
				</property>
				<property name="packagesToScan">
					<list>
						<value>com.java.test.domain</value>
					</list>
				</property>
				<property name="annotatedPackages">
					<list>
						<value>com.java.test.domain</value>
					</list>
				</property>
			</bean>
        
        ---------------------------------------
        c. Configure transaction with AOP
        ---------------------------------------
        	<!-- Enable @Transaction annotation -->
			<tx:annotation-driven transaction-manager="testTransactionManager" mode="aspectj"/>
			
        	<!-- Transaction Manager Configuration -->
			<bean id="testTransactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager" autowire-candidate="true">
				<property name="sessionFactory" ref="testSessionFactory" />
			</bean>
        
        ---------------------------------------
        d. Extend DAO implementation from HibernateDaoSupport or use HibernateTemplate or use sessionFactory.getCurrentSession()
        ---------------------------------------
        
        	@Repository
			public class BaseDaoImpl implements BaseDao {
			
				@Resource(name = "testSessionFactory")
				private SessionFactory sessionFactory;
			
				@Override
				public Session getSession() {
					return sessionFactory.getCurrentSession();
				}
				
				@Override
				public Criteria createCriteria(Class<? extends Serializable> persistentClass) {
					return getSession().createCriteria(persistentClass);
				}
				
				@Override
				public <T extends Serializable> T fetchEntityById(Class<T> entityClass, Serializable id) {
					Session session = getSession();
					return entityClass.cast(session.get(entityClass, id));
				}
				
				@Override
				public void save(Serializable entity) {
					Session session = getSession();
					session.saveOrUpdate(entity);
					session.flush();
				}
				
				@Override
				public void saveAll(Collection<? extends Serializable> entities) {
					Session session = getSession();
					for (Serializable anEntity : entities) {
						session.saveOrUpdate(anEntity);
					}
					session.flush();
				}
				
				@Override
				public void merge(Serializable entity) {
					Session session = getSession();
					session.merge(entity);
				}
				
			}

------------------------------------------------------------------------------------------
Spring JDBC
------------------------------------------------------------------------------------------
1. JdbcTemplate
    Spring-JDBC provides the JdbcTemplate class, that removes plumbing code and helps you concentrate on the SQL query and parameters.
    You just need to configure it with a DataSource.
    You can then write code like this:
    int nbRows = jdbcTemplate.queryForObject("select count(1) from person", Integer.class);

    Person p = jdbcTemplate.queryForObject("select first, last from person where id=?", 
             	rs -> new Person(rs.getString(1), rs.getString(2)), 134561351656L);

2. JdbcDaoSupport
    Spring-JDBC also provides a JdbcDaoSupport, that you can extend to develop your DAO. 
    It basically defines 2 properties: a DataSource and a JdbcTemplate that both can be used to implement the DAO methods. 
    It also provides an exceptions translator from SQL exceptions to spring DataAccessExceptions.

3. What is Spring's JdbcTemplate?
    Spring's JdbcTemplate is central class to interact with a database through JDBC.
    It provides many convenience methods for converting database data into primitives or objects,
        executing prepared and callable statements, and providing custom database error handling

------------------------------------------------------------------------------------------
Spring Data
------------------------------------------------------------------------------------------
    - Spring-Data provides a common API to define how to access data (DAO + annotations) in a more generic way, 
        covering both SQL and NOSQL data sources.
    - Spring-Data concentrates on non-SQL technologies, but still provides a module for JPA (the only SQL technology).
    - When the application context is loaded, spring provides proxies for the DAO interfaces,
         that contain all the boilerplate code related to the data access technology, and invokes the configured queries.

------------------------------------------------------------------------------------------
Spring Data vs Spring DAO vs Spring ORM vs Spring JDBC
------------------------------------------------------------------------------------------
https://stackoverflow.com/questions/24990400/spring-dao-vs-spring-orm-vs-spring-jdbc


What are the annotations I should be using for REST service development in Spring?
What is JTA tx? 
    - I have a situation wherein I have to insert in one DB, update in another DB, 
      write the data to a cache system (a regular in-memory cache) and send a notification email. 
      Out of these, which can be put under JTA tx?
What is the Spring frame work used in projects - Spring MVC
How are we going to send request back to front end from controller?
How will application identify get, put and post methods?
How will you send the request from JS to Java layer?
What is Java script frame work used in project - JQuery
How Spring DAO transaction works (high-level)?

------------------------------------------------------------------------------------------
Spring Boot:
------------------------------------------------------------------------------------------
# Remote debugging config:
	JAVA_OPTS: "-Xdebug -Xrunjdwp:server=y,transport=dt_socket,suspend=n"
